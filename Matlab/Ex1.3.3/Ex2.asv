clear; clc;
%№1
close all
%Локон Аньези
% f = 0:0.1:180;
% rf = f *pi/180;
% a = 10;
% x = a * tan(rf);
% y = a * cos(rf) .^ 2;
t = -10:0.1:10;
rt = t * pi/180;
a = 10;
x = 2 .* a * t;
y = (2 .* a )./( 1 + (t .^ 2));
figure
plot(x,y)
title('Верзьера Аньези');

t = 0:0.1:pi;
rt = t * pi/180;
x = 2 * atan(rt);
y = a * (1 - cos(2 * rt));
figure
plot(x,y)
title('Верзьера Аньези');

% %Суперэлипс % думаю проблема в том что  результат вычесления переводится в
% комплексное число проблему решить не могу побывал преобразовать дробную
% степень а вычесление через корень и степень.Ошибка пропала необходимый график
% не вышел.Необходима подсказка.
a = 1;
b = 1;
n = 4;
o = 0:100000;
ro = o * pi/180;
x = a *(cos(ro).^(2/n));
y = b *(sin(ro).^(2/n));
x = [-x x];
y = [-y y];
x = abs(x);
x = abs(y);
figure
plot(x,y)
title('Суперэллипс');



%Архимедова спираль%
k = 10;
f = 1:100;
p = k * f;
figure
polarplot(p)
title('Архимедова спираль - полярная');


%если по такой же формуле бред получается
k = 10;
f = 1:100;
p = k * f;
t = 0:0.01:10;
%не таакая же формула получается другая.Или я ваши слова не так понял.
x = t .* cos(t);
y = t .* sin(t);
figure
plot(x,y)
title('Архимедова спираль - декатрова')


%№2(1)
%Гипоциклойда.Уверен что вы совсем не это хотите увидеть.проба пера.
R = 6;
r1 = 1;
k1 = R/r1;
t = 1:10000;
t = t*pi/180;
x1 = r1*(k1 - 1)*(cos(t)+cos((k1-1)*t)/(k1-1));
y1 = r1*(k1 - 1)*(sin(t)- sin((k1-1)*t)/(k1-1));
r2 = 2;
k2 = R/r2;
t = 1:10000;
t = t*pi/180;
x2 = r2*(k2 - 1)*(cos(t)+cos((k2-1)*t)/(k2-1));
y2 = r1*(k2 - 1)*(sin(t)- sin((k2-1)*t)/(k2-1));
r3 = 3;
k3 = R/r3;
t = 1:10000;
t = t*pi/180;
x3 = r3*(k3 - 1)*(cos(t)+cos((k3-1)*t)/(k3-1));
y3 = r3*(k3 - 1)*(sin(t)- sin((k3-1)*t)/(k3-1));
r4 = 4;
k4  = R/r4;
t = 1:10000;
t = t*pi/180;
x4 = r4*(k4 - 1)*(cos(t)+cos((k4-1)*t)/(k4-1));
y4= r4*(k4 - 1)*(sin(t)- sin((k4-1)*t)/(k4-1));
figure
plot(x1,y1,x2,y2,x3,y3,x4,y4)
axis equal tight
title('Серия кривых');



%№2(2)Meняем R.Задумка была сделать матрици и производить действия над
%ними.Однако  график выводится не верный.Нужна подсказка.
R = [3 4 5 6];
r = 1;
k = R/r;

lgr = length(R);
t = 1:10000;
lgt = length(t);
MR = zeros(lgr,lgt);
MT = zeros(lgr,lgt);

s = 0;
while s < lgr %исключительно для возможности изменения количества элементов начаьного вектора
    s = s+1;
    MR(s,:)= R(s);
end
s = 0;
while s < lgr %исключительно для упрощения 
   s = s+1;
   MT(s,:) = t;
end
k = MR/r;
MTR = MT*pi/180;
mk = k - 1;
x = r .* mk .* (cos(MTR)+ cos(MTR .* mk)./mk);
y = r .* mk .* (sin(MTR)- sin(MTR .* mk)./mk);
figure
plot(x(1,:),y(1,:),x(2,:),y(2,:),x(3,:),y(3,:),x(4,:),y(4,:))
axis equal tight
title('Серия кривых 2')

%N2(3)Разобрался как работает.Класно!Я даже и не думал.Так как что такое
%транспонирование я уже похже освоил в блоке высщей математики.Умножение
%матриц так же.
t = 0:0.01:20;
R = [3 4 5 6]';
r = 1;
k = R/r;
x = r*(k - 1).*(cos(t)+cos((k-1).*t)./(k-1));
y = r*(k - 1).*(sin(t)- sin((k-1).*t)./(k-1));
figure
plot(x',y')
axis equal tight
title('Серия кривых 3')


%№3
m1 = 5;
m2 = 1;
g = 9.81;
w = 200*pi/30;
l = 0.2;
ot = 60;
MR = zeros(1,60);
s = 0;
gt = 1:0.1:ot; %Нюанс понял шаг изменения уменьшил
for ct = 0:0.1:ot - 1 
    s = s + 1;
    rt = ct * pi/180;
    R = (m1+m2)*g - m2 * w^2 * l * sin(w * rt);
    if R > 0
        MR(s)= R;
    end   
end
figure
plot(gt,MR)
title('График значеия реакции опоры двигателя ко времяни.');

m1 = 5;
m2 = 1;
g = 9.81;
w = 200*pi/30;
l = 0.2;
ot = 60;
gt = 1:0.1:ot;
R = (m1+m2)*g - m2 * w^2 * l * sin(w * gt)
sfr = length(R)
RL = R > 0
mrl = R .* RL
figure
plot(gt,MR)
title('График значеия реакции опоры двигателя ко времяни.');
